# RF Spectrum Processing Monorepo

This repository contains a FastAPI backend and a Next.js frontend used to explore RF spectrum artifacts generated by the batch processor. The backend exposes REST endpoints and a playback WebSocket, while the frontend renders summary traces, waterfall heatmaps, peak detection, and marker controls.

## Repository Layout

```
backend/        FastAPI application
frontend/       Next.js application
backend/app/tests/  Pytest suite covering dataset slicing
```

## Backend

The FastAPI backend exposes the following endpoints:

- `GET /bands` – list available bands discovered from `meta_*.json` files.
- `GET /bands/{id}/meta` – retrieve metadata for a band.
- `GET /bands/{id}/summary?f0&f1&max_pts` – summary traces with server-side decimation.
- `GET /bands/{id}/waterfall_tile?f0&f1&t0&t1&maxw&maxt&fmt` – resampled waterfall tile as PNG (default) or compressed matrix.
- `POST /bands/{id}/peaks` – SciPy-based peak detection for a selected summary curve and frequency window.
- `GET /bands/{id}/markers` – load stored markers for a band.
- `POST /bands/{id}/markers` – replace markers for a band.
- `WS /ws/bands/{id}?window_s&fps` – playback ticks with rolling time windows.

Artifacts are read lazily using NumPy memmaps. The `DatasetService` avoids loading entire waterfalls into memory and provides helper methods for slicing and downsampling along time and frequency axes.

## Frontend

The Next.js app provides two pages:

- `/` – list available bands.
- `/bands/[id]` – interactive explorer combining Plotly traces, deck.gl waterfall heatmap, peak detection controls, playback bar, and marker management panel.

Key components:

- `TracePlot` – Plotly.js line traces with peak overlays and zoom callbacks.
- `Waterfall` – deck.gl BitmapLayer rendering the resampled waterfall PNG.
- `PeakControls` – UI for configuring peak detection parameters.
- `PlaybackBar` – WebSocket-driven playback window display.
- `MarkersPanel` – CRUD UI for band markers.

API utilities are provided in `frontend/lib/api.ts` to communicate with the backend.

## Running with Docker Compose

1. Place your RF artifact files inside `./data` so that the container can mount them at `/data`.
2. Build and start the services:

   ```bash
   docker-compose up --build
   ```

3. Access the frontend at http://localhost:3000 and the backend docs at http://localhost:8000/docs.

## Local Development

### Backend

Create a virtual environment and install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r backend/requirements.txt
```

Run the API locally:

```bash
uvicorn app.main:app --app-dir backend/app --reload
```

### Frontend

```bash
cd frontend
npm install
npm run dev
```

Set `NEXT_PUBLIC_API_BASE` to point at the backend (defaults to `http://localhost:8000`).

## Testing

Run the dataset slicing tests:

```bash
pytest backend/app/tests
```

The tests create synthetic artifact files to validate summary and waterfall resampling, as well as marker persistence.
